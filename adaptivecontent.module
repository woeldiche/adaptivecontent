<?php

/**
 * @files
 *
 */

/**
 * Implements hook_premission().
 */
function adaptivecontent_permission() {
  return array(
    'adaptivecontent administer' => array(
      'title' => t('Administer Adaptive Content'),
    ),
    'adaptivecontent create preset' => array(
      'title' => t('Create preset'),
    ),
    'adaptivecontent edit preset' => array(
      'title' => t('Edit preset'),
    ),
    'adaptivecontent delete preset' => array(
      'title' => t('Delete preset'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function adaptivecontent_menu() {
  $items = array();

  // Load information about the theme available
  $themes_info = list_themes();

  $items['admin/config/content/adaptivecontent'] = array(
    'title' => 'Adaptive Content',
    'description' => t('Adaptive Content presets.'),
    'page callback' => 'adaptivecontent_presets',
    'access arguments' => array('administer adaptivecontent'),
    'file' => 'adaptivecontent.preset.inc',
    'file path' => drupal_get_path('module', 'adaptivecontent') . '/includes',
    'type' => MENU_NORMAL_ITEM,
  );

  $items['admin/config/content/adaptivecontent/presets'] = array(
    'title' => 'Presets',
    'description' => t('Adaptive Content presets.'),
    'page callback' => 'adaptivecontent_presets',
    'access arguments' => array('administer adaptivecontent'),
    'file' => 'adaptivecontent.preset.inc',
    'file path' => drupal_get_path('module', 'adaptivecontent') . '/includes',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );

  $items['admin/config/content/adaptivecontent/presets/add'] = array(
    'title' => 'Add preset',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('adaptivecontent_preset_edit_form'),
    'access arguments' => array('adaptivecontent create preset'),
    'type' => MENU_LOCAL_ACTION,
    'file' => 'adaptivecontent.preset.inc',
    'file path' => drupal_get_path('module', 'adaptivecontent') . '/includes',
  );

  $items['admin/config/content/adaptivecontent/presets/%/edit'] = array(
    'title' => 'Edit preset',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('adaptivecontent_preset_edit_form', 5),
    'access arguments' => array('adaptivecontent edit preset'),
    'type' => MENU_CALLBACK,
    'file' => 'adaptivecontent.preset.inc',
    'file path' => drupal_get_path('module', 'adaptivecontent') . '/includes',
  );

  $items['admin/config/content/adaptivecontent/presets/%/delete'] = array(
    'title' => 'Delete preset',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('adaptivecontent_preset_delete_form', 5),
    'access arguments' => array('adaptivecontent delete preset'),
    'type' => MENU_CALLBACK,
    'file' => 'adaptivecontent.preset.inc',
    'file path' => drupal_get_path('module', 'adaptivecontent') . '/includes',
  );

  // If omega exists and is enable, add link to import presets from omega.
  if (isset($themes_info['omega']) && $themes_info['omega']->status) {
    $items['admin/config/content/adaptivecontent/presets/import'] = array(
      'title' => 'Import Omega presets',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('adaptivecontent_preset_import'),
      'access arguments' => array('adaptivecontent omega import'),
      'type' => MENU_LOCAL_ACTION,
      'file' => 'adaptivecontent.preset.inc',
      'file path' => drupal_get_path('module', 'adaptivecontent') . '/includes',
    );
  }

  $items['admin/config/content/adaptivecontent/settings'] = array(
    'title' => 'Settings',
    'description' => t('Adaptive Content settings.'),
//    'page callback' => 'drupal_get_form',
    'page callback' => 'adaptivecontent_setting_form',
//    'page arguments' => array('adaptivecontent_setting_form'),
    'access arguments' => array('administer adaptivecontent'),
    'file' => 'adaptivecontent.setting.inc',
    'file path' => drupal_get_path('module', 'adaptivecontent') . '/includes',
    'type' => MENU_LOCAL_TASK,
  );

  $themes = array();
  foreach ($themes_info as $key => $theme) {
    if ($theme->status) {
      $items['admin/config/content/adaptivecontent/settings/' . $key] = array(
        'title' => $theme->name,
        'type' => MENU_LOCAL_TASK,
        'description' => t('Presets for %theme theme.', array('%theme' => $theme->name)),
        'page callback' => 'drupal_get_form',
        'page arguments' => array('adaptivecontent_theme_preset_form', 5),
        'access arguments' => array('administer adaptivecontent'),
        'file' => 'adaptivecontent.themes.inc',
        'file path' => drupal_get_path('module', 'adaptivecontent') . '/includes',
      );
    }
  }

  return $items;
}

/**
 * Set a static variable to indicate if this is a ajax callback for rendering
 * regions or rendering core content.
 *
 * @param boolean $value
 *  If value is TRUE one regions will be generated. It defaults to FALSE, which
 *  ensures that core content is rendered.
 * @return boolean
 *  Returns the current ajax state, if no parameter is passed.
 */
function adaptivecontent_set_ajax($value = NULL) {
  $ajax = &drupal_static(__FUNCTION__);
  if (isset($value)) {
    $ajax = $value;
  }
  else {
    $value = FALSE;
  }
  return $ajax;
}

/**
 * Load configuration for the currently active theme or the theme key the
 * function was called with.
 *
 * @todo Match new conf structure.
 *
 * @global type $theme_key
 * @param type $theme_key
 * @return type
 */
function adaptivecontent_load_configuration($theme_key= NULL) {
  if (!isset($theme_key)) {
    global $theme_key;
  }
  return variable_get('adaptivecontent_theme_' + $theme_key, array());
}

/**
 * Implements hook_init().
 *
 * Checks if the current request is for regions or core content. If the
 * responesive parameter is part of the request set ajax to true, so page alter
 * knowns that this is a call for render regions.
 *
 * @todo: This step may not be need any more, check up on that.
 *
 */
function adaptivecontent_init() {
  // @todo: is this an responsive callback ?
  if (isset($_GET['responsive'])) {
    $responsive = check_plain($_GET['responsive']);
    if ($responsive == 'true' || intval($responsive) == 1) {
      adaptivecontent_set_ajax(TRUE);
    }
  }
  _adaptivecontent_load_presets();
}

/**
 * Implements hook_page_alter().
 *
 * This function ensures that either regions are render and returned as JSON or
 * that the core content is returned with out the regions, which will be load be
 * by an ajax callback later.
 */
function adaptivecontent_page_alter(&$page) {
  if (adaptivecontent_set_ajax()) {
    // Run drupal_page_alter on themes, as they will always come last. In the
    // drupal_alter function, but we need to have all regions avaliable now. So
    // do the same as drupal_alter does with the themes. An better solution may
    // exists..
    adaptivecontent_theme_page_alter('page_alter', $page);
    $main_content_display = &drupal_static('system_main_content_added', FALSE);
    if (!$main_content_display) {
        $page['content']['system_main'] = drupal_set_page_content();
    }

    // Make sure that all page level hook_preprocess_page and hook_process_page
    // are executed to ensure suff like menus and other theme variables are
    // genenrated for use in the regions rendered later on. This code is
    // basically taken from theme.inc.
    $hooks = theme_get_registry(FALSE);
    $hook = 'page';
    $info = $hooks[$hook];

    // Merge in argument defaults.
    $variables = array();
    $variables[$info['render element']] = $page;
    if (!empty($info['variables'])) {
      $variables += $info['variables'];
    }
    elseif (!empty($info['render element'])) {
      $variables += array($info['render element'] => array());
    }
    if (isset($info['base hook'])) {
      $base_hook = $info['base hook'];
      $base_hook_info = $hooks[$base_hook];
      if (isset($base_hook_info['preprocess functions']) || isset($base_hook_info['process functions'])) {
        $variables['theme_hook_suggestion'] = $hook;
        $hook = $base_hook;
        $info = $base_hook_info;
      }
    }

    // Make sure that preprocess and process functions are executed.
    if (isset($info['preprocess functions']) || isset($info['process functions'])) {
      $variables['theme_hook_suggestions'] = array();
      foreach (array('preprocess functions', 'process functions') as $phase) {
        if (!empty($info[$phase])) {
          foreach ($info[$phase] as $processor_function) {
            if (function_exists($processor_function)) {
              // We don't want a poorly behaved process function changing $hook.
              $hook_clone = $hook;
              $processor_function($variables, $hook_clone);
            }
          }
        }
      }
      // This allows the preprocess/process step to route to a more specific
      // theme hook.
      $suggestions = array();
      if (!empty($variables['theme_hook_suggestions'])) {
        $suggestions = $variables['theme_hook_suggestions'];
      }
      if (!empty($variables['theme_hook_suggestion'])) {
        $suggestions[] = $variables['theme_hook_suggestion'];
      }
      foreach (array_reverse($suggestions) as $suggestion) {
        if (isset($hooks[$suggestion])) {
          $info = $hooks[$suggestion];
          break;
        }
      }
    }

    // @todo: Fix form callback URI's as they will contain the ajax callback
    // parameters, when rendered below. SOLUTION: use post's not get's.

    // @todo: move parsing of parameters into own fuction.

    // Check if a preset was in the ajax callback
    $regions = array();
    if (isset($_GET['preset'])) {
      $preset = check_plain($_GET['preset']);
      $conf = adaptivecontent_load_configuration();
      $regions = isset($conf[$preset]['regions']) ? $conf[$preset]['regions'] : array();
    }

    // Check if any regions was in the ajax callback.
    if (isset($_GET['regions']) && empty($regions)) {
      $names = explode(',', check_plain($_GET['regions']));
      foreach ($names as $name) {
        $regions[$name] = $name;
      }
    }

    // Render the regions.
    $output = array();
    $regions_arrays = adaptivecontent_find_regions($page, array_filter($regions));
    foreach ($regions_arrays as $name => $array) {
      $output[$name] = drupal_render($array);
    }

    drupal_json_output($output);
    drupal_exit();
  }

  // Load configuration.
  $conf = adaptivecontent_load_configuration();

  // Load regions from theme (omega do some suff that requires us to work on
  // copy). This creates some problem with the normal, where the theme have to
  // ensure that it do not call these them self... see patch for alpha.
  adaptivecontent_theme_page_alter('page_alter', $page);
  adaptivecontent_disable_regions($page, $conf['core']['regions']);
}

/**
 * Disables regions in an render array.
 *
 * @param array $data
 *  Render array representing an page.
 * @param array $regions
 *  An array with the names of the regions that should be disabled with the
 *  region name as key and the value '0' for disable and '1' for enable.
 */
function adaptivecontent_disable_regions(&$data, $regions) {
  // @todo: apply cache to speed up walker based on preset. Make the optional.
  $keys = array_keys($data);
  foreach ($keys as $key) {
    if ((!preg_match('/^#/', $key)) && is_array($data[$key])) {
      if (isset($data[$key]['#region'])) {
        if (isset($regions[$key]) && $regions[$key] == '0') {
          $data[$key]['#access'] = FALSE;

          // Place makers in regions to ajax load regions to create place holders and
          // enble theme.
        }
      }
      adaptivecontent_disable_regions($data[$key], $regions);
    }
  }
}

/**
 * Find the render array for regions in the page render array.
 *
 * @param array $data
 *  Page render array.
 * @param array $regions
 *  The regions which should be extracted from the array, the key an value
 *  should be the same (e.g 'menu' => 'menu').
 * @return array
 *  Regions found indexed by region name.
 */
function adaptivecontent_find_regions(&$data, $regions) {
  // @todo: apply cache to speed up walker based on preset. Make the optional.
  $array = array();
  $keys = array_keys($data);
  foreach ($keys as $key) {
    if ((!preg_match('/^#/', $key)) && is_array($data[$key])) {
      if (isset($data[$key]['#region']) && isset($regions[$key])) {
        $array[$key] = $data[$key];
        // $array[] = render array for region.

        // pop $regions
        unset($regions[$key]);

        // If $regions empty break loop, no more finding need.
        if (empty($regions)) {
          break;
        }
      }
      $array = array_merge(adaptivecontent_find_regions($data[$key], $regions), $array);
    }
  }
  return $array;
}

/**
 * Calls theme alters and makes sure that the theme gets a change to alter
 * regions befor they are rendered.
 *
 * @global type $theme
 * @global type $base_theme_info
 * @staticvar type $drupal_static_fast
 * @param type $hook
 * @param type $data
 */
function adaptivecontent_theme_page_alter($hook, &$data) {
  static $drupal_static_fast;
  if (!isset($drupal_static_fast)) {
    $drupal_static_fast['functions'] = &drupal_static('drupal_alter');
  }
  $functions = &$drupal_static_fast['functions'];

  global $theme, $base_theme_info;
  $theme_alters = array();
  if (isset($theme)) {
    $theme_keys = array();
    foreach ($base_theme_info as $base) {
      $theme_keys[] = $base->name;
    }
    $theme_keys[] = $theme;
    foreach ($theme_keys as $theme_key) {
      $function = $theme_key . '_' . $hook;
      if (function_exists($function)) {
        $theme_alters[] = $function;
      }
    }
  }

  // Call hooks and save theme in the cache.
  foreach ($theme_alters as $function) {
    $function($data);
    $functions[$hook][] = $function;
  }
}

/**
 * Loads an preset based on preset name if given. If no name is given all
 * presets are loaded.
 *
 * This function uses an static cache.
 *
 * @param string $name The name of the preset to load.
 * @param boolean $reset Reset the static cache, defaults to FALSE.
 * @return mixed Returns an array with preset(s) or FALSE if the preset was not
 * found.
 */
function _adaptivecontent_load_presets($name = NULL, $reset = FALSE) {
  $presets = &drupal_static(__FUNCTION__);
  if (!isset($presets[$name]) || $reset) {
    if (!isset($name)) {
      $results = db_select('adaptivecontent_presets', 'ap')
                  ->fields('ap', array('pid', 'name', 'human_name', 'query'))
                  ->execute();
    }
    else {
      $results = db_select('adaptivecontent_presets', 'ap')
                  ->fields('ap', array('pid', 'name', 'human_name', 'query'))
                  ->condition('name', $name)
                  ->execute();
    }

    // Loop over results.
    foreach ($results as $result) {
      $presets[$result->name] = array(
        'pid' => $result->pid,
        'name' => $result->name,
        'human_name' => $result->human_name,
        'query' => $result->query,
      );
    }
  }

  if (isset($name)) {
    if (isset($presets[$name])) {
      return $presets[$name];
    }
    return FALSE;
  }

  if (isset($presets) && !empty($presets)) {
    return $presets;
  }

  return FALSE;
}

/**
 *
 *
 * @param type $name
 * @param type $human_name
 * @param type $query
 * @param type $pid
 */
function _adaptivecontent_save_preset($name, $human_name, $query, $pid = NULL) {
  if (isset($pid)) {
    db_update('adaptivecontent_presets')
      ->fields(array(
        'human_name' => $human_name,
        'query' => $query,
      ))
      ->condition('pid', $pid, '=')
      ->execute();
  }
  else {
    // ID is not given, so this must be a new preset.
    db_insert('adaptivecontent_presets')
      ->fields(array('name' => $name,
                    'human_name' => $human_name,
                    'query' => $query))
      ->execute();
  }
}

function _adaptivecontent_delete_preset($pid) {
  db_delete('adaptivecontent_presets')
    ->condition('pid', $pid, '=')
    ->execute();
}